<!DOCTYPE html><html lang="en-lang"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title>JVM垃圾回收 · dxer</title><meta name="description" content="JVM垃圾回收 - dxer"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.ico"><link rel="stylesheet" href="/css/style.css"><!-- fonts--><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" href="http://fonts.lug.ustc.edu.cn/css?family=Source+Sans+Pro:400,600" type="text/css"><!-- baidu analytics--><script type="text/javascript">var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?824de59e952801cadc44270759e656b9";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><!-- google analytics--><script type="text/javascript">(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-43614462-1', 'auto');
ga('send', 'pageview');</script></head><body><input type="checkbox" id="sidebar-toggle"><aside><div class="author"><a href="/."><img src="/img/author.png" class="author-img"></a><h2 class="author-name">dxer</h2></div><div class="post-toc"><span class="toc-title">Directory</span><ol class="toc"><li class="toc-item toc-level-5"><a class="toc-link" href="#新生代-Young-Generation"><span class="toc-text">新生代(Young Generation)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#老年代-Old-Generation"><span class="toc-text">老年代(Old Generation)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#永久代-Permanent-Generation"><span class="toc-text">永久代(Permanent Generation)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#方法区"><span class="toc-text">方法区</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#内存池"><span class="toc-text">内存池</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#运行时常量池"><span class="toc-text">运行时常量池</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Java栈内存"><span class="toc-text">Java栈内存</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Java-堆内存开关"><span class="toc-text">Java 堆内存开关</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Java垃圾回收"><span class="toc-text">Java垃圾回收</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Java垃圾回收类型"><span class="toc-text">Java垃圾回收类型</span></a></li></ol></div></aside><div class="main"><header><div id="top"><a href="/." class="logo-link">dxer</a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">Home</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">Archive</a></li><li class="nav-list-item"><a href="/tags/" target="_self" class="nav-list-link">Tags</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">About</a></li></ul></div></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">JVM垃圾回收</h1><div class="post-time">Aug 17, 2015</div><div class="post-content"><p>JVM堆内存被分为两部分<em>年轻代(Young Generation)</em>和<em>老年代(Old Generation)</em>。</p>
<h5 id="新生代-Young-Generation"><a href="#新生代-Young-Generation" class="headerlink" title="新生代(Young Generation)"></a>新生代(Young Generation)</h5><p>新生代是所有新对象产生的地方。当年轻代的内存空间被用完时，就会触发垃圾回收。这个垃圾回收叫做<em>Minor GC</em>。新生代分为3个部分<em>Eden区</em>和<em>Survivor区(FromSpace和ToSpace,两个区域大小相同)</em>，新生代的大小可以通过<code>-Xmn</code>来控制，也可以用<code>-XX：SurvivorRatio</code>来控制Eden和Survivor的比例。</p>
<p>新生代的特点</p>
<ul>
<li>大多数新建的对象都在Eden区</li>
<li>当Eden区域被填满时，就会执行Minor GC。并把所有存活下来的对象转移到其中一个survivor区</li>
<li>Minor GC同样会检查存活下来的对象，并把他们转移到另一个survivor区。这样在一段时间内，总会有一个空的survivor区</li>
<li>经过多次GC周期后，仍然存活下来的对象会被转移到老年代内存空间。通常这是在新生代有资格提升到老年代前通过设定年龄阈值来完成的。</li>
</ul>
<h5 id="老年代-Old-Generation"><a href="#老年代-Old-Generation" class="headerlink" title="老年代(Old Generation)"></a>老年代(Old Generation)</h5><p>老年代内存里包含了长期存活的对象和经过多次Minor GC后依然存活下来的对象。通常会在老年代内存被占满时进行垃圾回收。老年代的垃圾收集叫做Major GC。Major GC会花费更多的时间。旧生带占用大小为<code>-Xmx</code>值减去<code>-Xmn</code>对应的值</p>
<h5 id="永久代-Permanent-Generation"><a href="#永久代-Permanent-Generation" class="headerlink" title="永久代(Permanent Generation)"></a>永久代(Permanent Generation)</h5><p>永久代包含了JVM需要的应用元数据，这些元数据描述了在应用里使用的类和方法。注意，永久代不是Java堆内存的一部分，有一些JVM没有这一代，主要存放敞亮及类的一些信息，默认最小值为16MB，最大值为64MB，可以通过<code>-XX:PermSize</code>及<code>-XX:MaxPermSize</code>来设置最小值和最大值。</p>
<p>永久代存放JVM运行时使用的类。永久代同样包含了Java SE库的类和方法。永久代的对象在full GC时进行垃圾收集。</p>
<h5 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h5><p>方法区是永久代空间的一部分，并用来存储类型信息（运行时常量和静态变量）和方法代码和构造函数代码。</p>
<h5 id="内存池"><a href="#内存池" class="headerlink" title="内存池"></a>内存池</h5><p>如果JVM实现支持，JVM内存管理会为创建内存池，用来为不变对象创建对象池。字符串池就是内存池类型的一个很好的例子。内存池可以属于堆或者永久代，这取决于JVM内存管理的实现。</p>
<h5 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h5><p>运行时常量池是每个类常量池的运行时代表。它包含了类的运行时常量和静态方法。运行时常量池是方法区的一部分。</p>
<h5 id="Java栈内存"><a href="#Java栈内存" class="headerlink" title="Java栈内存"></a>Java栈内存</h5><p>Java栈内存用于运行线程。它们包含了方法里的临时数据、堆里其它对象引用的特定数据。你可以阅读栈内存和堆内存的区别。</p>
<h5 id="Java-堆内存开关"><a href="#Java-堆内存开关" class="headerlink" title="Java 堆内存开关"></a>Java 堆内存开关</h5><table>
<thead>
<tr>
<th>VM设置</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>-Xms</td>
<td>设置JVM启动时堆的初始化大小。</td>
</tr>
<tr>
<td>-Xmx</td>
<td>设置堆最大值。</td>
</tr>
<tr>
<td>-Xmn</td>
<td>设置年轻代的空间大小，剩下的为老年代的空间大小。</td>
</tr>
<tr>
<td>-XX:PermGen</td>
<td>设置永久代内存的初始化大小。</td>
</tr>
<tr>
<td>-XX:MaxPermGen</td>
<td>设置永久代的最大值。</td>
</tr>
<tr>
<td>-XX:SurvivorRatio</td>
<td>提供Eden区和survivor区的空间比例。比如，如果年轻代的大小为10m并且VM开关是-XX:SurvivorRatio=2，那么将会保留5m内存给Eden区和每个Survivor区分配2.5m内存。默认比例是8。</td>
</tr>
<tr>
<td>-XX:NewRatio</td>
<td>提供年老代和年轻代的比例大小。默认值是2。</td>
</tr>
</tbody>
</table>
<p>大多数时候，上面的选项已经足够使用了。但是如果你还想了解其他的选项，那么请查看JVM选项官方网页。</p>
<h5 id="Java垃圾回收"><a href="#Java垃圾回收" class="headerlink" title="Java垃圾回收"></a>Java垃圾回收</h5><p>JVM堆内存主要被分为三块，新生代、老年代、持久代。三代的特点不同，造就了他们所用的GC算法不同，新生代适合那些生命周期较短，频繁创建及销毁的对象，老年代适合生命周期相对较长的对象，持久代在Sun HotSpot中就是指方法区（有些JVM中根本就没有持久代这中说法）。</p>
<p>Java垃圾回收会找出没用的对象，把它从内存中移除并释放出内存给以后创建的对象使用。Java程序语言中的一个最大优点是自动垃圾回收，不像其他的程序语言那样需要手动分配和释放内存，比如C语言。</p>
<p>垃圾收集器是一个后台运行程序。它管理着内存中的所有对象并找出没被引用的对象。所有的这些未引用的对象都会被删除，回收它们的空间并分配给其他对象。</p>
<p>一个基本的垃圾回收过程涉及三个步骤：</p>
<ol>
<li>标记：这是第一步。在这一步，垃圾收集器会找出哪些对象正在使用和哪些对象不在使用。</li>
<li>正常清除：垃圾收集器清会除不在使用的对象，回收它们的空间分配给其他对象。</li>
<li>压缩清除：为了提升性能，压缩清除会在删除没用的对象后，把所有存活的对象移到一起。这样可以提高分配新对象的效率。</li>
</ol>
<p>简单标记和清除方法存在两个问题：</p>
<ol>
<li>效率很低。因为大多数新建对象都会成为“没用对象”。</li>
<li>经过多次垃圾回收周期的对象很有可能在以后的周期也会存活下来。<br>上面简单清除方法的问题在于Java垃圾收集的分代回收的，而且在堆内存里有年轻代和年老代两个区域。我已经在上面解释了Minor GC和Major GC是怎样扫描对象，以及如何把对象从一个分代空间移到另外一个分代空间。</li>
</ol>
<h5 id="Java垃圾回收类型"><a href="#Java垃圾回收类型" class="headerlink" title="Java垃圾回收类型"></a>Java垃圾回收类型</h5><p>这里有五种可以在应用里使用的垃圾回收类型。仅需要使用JVM开关就可以在我们的应用里启用垃圾回收策略。让我们一起来逐一了解：</p>
<ol>
<li>Serial GC（-XX:+UseSerialGC）：Serial GC使用简单的标记、清除、压缩方法对年轻代和年老代进行垃圾回收，即Minor GC和Major GC。Serial GC在client模式（客户端模式）很有用，比如在简单的独立应用和CPU配置较低的机器。这个模式对占有内存较少的应用很管用。</li>
<li>Parallel GC（-XX:+UseParallelGC）：除了会产生N个线程来进行年轻代的垃圾收集外，Parallel GC和Serial GC几乎一样。这里的N是系统CPU的核数。我们可以使用 -XX:ParallelGCThreads=n 这个JVM选项来控制线程数量。并行垃圾收集器也叫throughput收集器。因为它使用了多CPU加快垃圾回收性能。Parallel GC在进行年老代垃圾收集时使用单线程。</li>
<li>Parallel Old GC（-XX:+UseParallelOldGC）：和Parallel GC一样。不同之处，Parallel Old GC在年轻代垃圾收集和年老代垃圾回收时都使用多线程收集。</li>
<li>并发标记清除（CMS）收集器（-XX:+UseConcMarkSweepGC)：CMS收集器也被称为短暂停顿并发收集器。它是对年老代进行垃圾收集的。CMS收集器通过多线程并发进行垃圾回收，尽量减少垃圾收集造成的停顿。CMS收集器对年轻代进行垃圾回收使用的算法和Parallel收集器一样。这个垃圾收集器适用于不能忍受长时间停顿要求快速响应的应用。可使用 -XX:ParallelCMSThreads=n JVM选项来限制CMS收集器的线程数量。</li>
<li>G1垃圾收集器（-XX:+UseG1GC) G1（Garbage First）：垃圾收集器是在Java 7后才可以使用的特性，它的长远目标时代替CMS收集器。G1收集器是一个并行的、并发的和增量式压缩短暂停顿的垃圾收集器。G1收集器和其他的收集器运行方式不一样，不区分年轻代和年老代空间。它把堆空间划分为多个大小相等的区域。当进行垃圾收集时，它会优先收集存活对象较少的区域，因此叫“Garbage First”。你可以在Oracle Garbage-FIrst收集器文档找到更多详细信息。</li>
</ol>
</div></article></div><div class="tags"><a href="/tags/java/">java</a><a href="/tags/jvm/">jvm</a></div><div class="paginator"><a href="/2015/10/25/hadoop_serializable/" class="prev"><i class="fa fa-chevron-left"></i><span> Prev</span></a><a href="/2015/05/07/redis-persistence/" class="next"><span>Next</span><i class="fa fa-chevron-right"></i></a></div></section><footer><div class="copyright"><p>© 2016<span class="heart"><i class="icon-next-heart fa fa-heart"></i></span><a href="http://dxer.github.io">dxer</a></p></div><div style="display:none"><script src="http://s11.cnzz.com/z_stat.php?id=1254885963&web_id=1254885963" language="JavaScript"></script></div></footer></div><label class="back2top"> <a href="#top"><i class="fa fa-chevron-up"></i></a></label></body></html>