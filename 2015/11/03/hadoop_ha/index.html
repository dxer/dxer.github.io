<!DOCTYPE html><html lang="en-lang"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title>【Hadoop学习】Hadoop2.0高可用性 · dxer</title><meta name="description" content="【Hadoop学习】Hadoop2.0高可用性 - dxer"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.ico"><link rel="stylesheet" href="/css/style.css"><!-- fonts--><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" href="http://fonts.lug.ustc.edu.cn/css?family=Source+Sans+Pro:400,600" type="text/css"><!-- baidu analytics--><script type="text/javascript">var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?824de59e952801cadc44270759e656b9";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><!-- google analytics--><script type="text/javascript">(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-43614462-1', 'auto');
ga('send', 'pageview');</script></head><body><input type="checkbox" id="sidebar-toggle"><aside><div class="author"><a href="/."><img src="/img/author.png" class="author-img"></a><h2 class="author-name">dxer</h2></div><div class="post-toc"><span class="toc-title">Directory</span><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#基本原理"><span class="toc-text">基本原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NFS方式"><span class="toc-text">NFS方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#QJM方式"><span class="toc-text">QJM方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NameNode故障切换"><span class="toc-text">NameNode故障切换</span></a></li></ol></div></aside><div class="main"><header><div id="top"><a href="/." class="logo-link">dxer</a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">Home</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">Archive</a></li><li class="nav-list-item"><a href="/tags/" target="_self" class="nav-list-link">Tags</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">About</a></li></ul></div></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">【Hadoop学习】Hadoop2.0高可用性</h1><div class="post-time">Nov 3, 2015</div><div class="post-content"><p>在Hadoop2.0之前，只有一个NameNode，虽然有SecondaryNameNode（不能迅速切换，需要花费一定时间恢复），还是存在单点问题。NameNode在Hadoop中就好比是人的心脏，不能停止工作。如果NameNode数据丢失或者不能工作，那整个集群就不能恢复了。<br><a id="more"></a></p>
<p>在Hadoop2.0中解决了这个问题，在Hadoop2.0中NameNode不再只是一个，可以有多个。每一个都具有相同的职能，一个NameNode是active状态，一个是standby状态。当集群在运行的时候，只有active状态的NameNode是正常工作的，standBy状态的NameNode是处于待命状态，时刻同步active状态NameNode的数据。一旦active状态的NameNode不能工作了，通过手工或者自动切换，standby状态的NameNode就可以转变为active状态了，这样集群还是正常工作了，这样集群就具有高可用性了。</p>
<p>Hadoop2.0的HA机制官方介绍了2中方式：</p>
<ol>
<li>NFS（Network File System）</li>
<li>QJM（Quorum Journal Manager）</li>
</ol>
<h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p><img src="/pic/20151103/HDFS_HA_arch.png" alt=""><br>Hadoop2.0中有两个NameNode，一个是active状态NameNode，一个是standby状态NameNode。两者的状态是可以切换的，但是不能同时都是active状态，最多只有一个active状态。只有active状态的NameNode对外提供服务，standby状态的NameNode不对外服务。active状态的NameNode和standby状态的NameNode之间通过NFS或者JN（journalnode，QJM方式）来同步数据。</p>
<p>active状态的NameNode会把最近的操作记录写到本地的edits文件中（edits file），并传输到NFS或者JN中。standby状态的NameNode定期检查，从NFS或者JN中把最近的edit文件读过来，然后把edits文件和fsimage文件合并成一个新的fsimage，合并完成之后会通知active状态NameNode来获取新的fsiamge，active状态NameNode获得到这个新的fsimage文件后，替换掉原来旧的fsimage文件。</p>
<h3 id="NFS方式"><a href="#NFS方式" class="headerlink" title="NFS方式"></a>NFS方式</h3><p><img src="/pic/20151103/ha_nfs.jpg" alt=""><br>NFS作为active NameNode和standby NameNode之间数据共享的存储，active状态的 NameNode会把最近的edits文件写到NFS，而standby状态的NameNode从NFS中读取edits文件。这个方式的缺点就是，如果active状态的NameNode或standby状态的NameNode有一个和NFS之间网络有问题是，就会造成它们之间数据的同步出现问题。</p>
<h3 id="QJM方式"><a href="#QJM方式" class="headerlink" title="QJM方式"></a>QJM方式</h3><p><img src="/pic/20151103/ha_qjm.jpg" alt=""><br>QJM方式可以解决NFS容错机制不足的问题，active状态NameNode和standby状态NameNode之间通过一组journalnode（奇数个，2n+1）来共享数据，active状态NameNode把最近的edits文件写到这组journalnode上，只要有n+1个写入成功就认为这次写入操作是成功的，然后standby状态NameNode就可以从journalnode上读取数据了。QJM方式有容错机制，可以容忍n个journalnode的失败</p>
<h3 id="NameNode故障切换"><a href="#NameNode故障切换" class="headerlink" title="NameNode故障切换"></a>NameNode故障切换</h3><p>active和standby状态NameNode可以随时切换，当active挂掉后，可以把standby切换成active状态。<br>故障切换可以通过人工切换和自动切换方式完成。</p>
<ul>
<li>人工切换是通过HA管理的命令来改变NameNode的状态</li>
<li>自动切换是在active状态NameNode挂掉的时候，standby状态NameNode自动切换成active状态，取代原来的active状态NameNode成为新的active状态NameNode，确保HDFS继续正常工作</li>
</ul>
<p><img src="/pic/20151103/ha.jpg" alt=""></p>
<p>自动切换需要配置zookeeper。集群中两个NameNode都在zookeeper中注册，当active状态的NameNode出现故障时，zookeeper能检查到这种情况，它就会自动把standby状态的NameNode切换为active状态。</p>
</div></article></div><div class="tags"><a href="/tags/hadoop/">hadoop</a><a href="/tags/bigdata/">bigdata</a><a href="/tags/ha/">ha</a></div><div class="paginator"><a href="/2015/11/03/yarn/" class="prev"><i class="fa fa-chevron-left"></i><span> Prev</span></a><a href="/2015/11/03/hadoop v1.0 and hadoopv2.0/" class="next"><span>Next</span><i class="fa fa-chevron-right"></i></a></div></section><footer><section id="comments"><div data-thread-key="http://dxer.github.io/2015/11/03/hadoop_ha/index.html" data-title="【Hadoop学习】Hadoop2.0高可用性" data-url="http://dxer.github.io/2015/11/03/hadoop_ha/index.html" class="ds-thread"></div><script type="text/javascript">var duoshuoQuery = {short_name: "smarthader" };
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds);
})();</script></section><div class="copyright"><p>© 2016<span class="heart"><i class="icon-next-heart fa fa-heart"></i></span><a href="http://dxer.github.io">dxer</a></p></div><div style="display:none"><script src="http://s11.cnzz.com/z_stat.php?id=1254885963&web_id=1254885963" language="JavaScript"></script></div></footer></div><label class="back2top"> <a href="#top"><i class="fa fa-chevron-up"></i></a></label></body></html>