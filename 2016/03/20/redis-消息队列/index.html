<!DOCTYPE html><html lang="en-lang"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title>Redis-消息队列 · dxer</title><meta name="description" content="Redis-消息队列 - dxer"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.ico"><link rel="stylesheet" href="/css/style.css"><!-- fonts--><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" href="http://fonts.lug.ustc.edu.cn/css?family=Source+Sans+Pro:400,600" type="text/css"><!-- baidu analytics--><script type="text/javascript">var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?824de59e952801cadc44270759e656b9";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><!-- google analytics--><script type="text/javascript">(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-43614462-1', 'auto');
ga('send', 'pageview');</script></head><body><input type="checkbox" id="sidebar-toggle"><aside><div class="author"><a href="/."><img src="/img/author.png" class="author-img"></a><h2 class="author-name">dxer</h2></div><div class="post-toc"><span class="toc-title">Directory</span><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#队列"><span class="toc-text">队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#使用任务队列的好处"><span class="toc-text">使用任务队列的好处</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#普通队列"><span class="toc-text">普通队列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#优先级队列"><span class="toc-text">优先级队列</span></a></li></ol></div></aside><div class="main"><header><div id="top"><a href="/." class="logo-link">dxer</a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">Home</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">Archive</a></li><li class="nav-list-item"><a href="/tags/" target="_self" class="nav-list-link">Tags</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">About</a></li></ul></div></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">Redis-消息队列</h1><div class="post-time">Mar 20, 2016</div><div class="post-content"><p>在网站开发中，当页面需要进行如发送邮件、发送短信、复杂数据运算等耗时较长的操作时会阻塞页面的渲染。为了避免用户等待太久，应该使用独立的线程来完成这类操作。不过一些编程语言或框架不易实现多线程，这时很容易就会想到通过其他进程来实现。设想有一个进程能够完成发邮件的功能，那么在页面中只需要想办法通知这个进程向指定的地址发送邮件就可以了。</p>
<p>更多的时候，服务器做的额外的事情，并不需要客户端等待，这时候就可以把这些额外的事情异步去做。处理异步任务的工具很多。主要还是处理通知消息，针对通知消息通常采用的是队列结构。这个异步处理的模型可以抽象为生产者和消费者模型。<br><a id="more"></a></p>
<p>redis中提供了两种方式来做消息队列，一个是使用生产者消费者模式，一种是使用发布订阅者模式。生产者消费者模式会让一个或者多个客户端监听消息队列，一旦有队列中有消息，消费者会马上去消费，谁先获得这个消息，谁就去处理。如果队列为空，则消费者继续监听。发布订阅者模式也是使用了一个或者多个客户端订阅消息频道，只要发布者发布了消息，所有的订阅者都能收到消息。</p>
<p>这里我们先看下生产者和消费者模型的消息队列。</p>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>与任务队列进行交互的实体有两类：</p>
<ul>
<li>生产者（producer）：生产者会将需要处理的任务放入任务队列中</li>
<li>消费者（consumer）：消费者不断从任务队列中读入任务信息并执行</li>
</ul>
<h3 id="使用任务队列的好处"><a href="#使用任务队列的好处" class="headerlink" title="使用任务队列的好处"></a>使用任务队列的好处</h3><ol>
<li>松耦合<br>生产者和消费者无需知道彼此的实现细节，只需要约定好任务的描述格式。这使得生产者和消费者可以由不同的团队使用不同的编程语言来进行开发。</li>
<li>易扩展<br>可以很方便的将消费者阔这到很多个，而且可以分布在不同的服务器中。</li>
</ol>
<h3 id="普通队列"><a href="#普通队列" class="headerlink" title="普通队列"></a>普通队列</h3><p>在redis中，可以使用列表（list）类型来实现。使用LPUSH和RPOP命令，<br>生产者将任务使用LPUSH命令加入到某个键中，消费者不断的使用RPOP命令从该键中取出任务。<br>代码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">	String task = jedis.rpop(<span class="string">"queue.task"</span>);</span><br><span class="line">	<span class="keyword">if</span>(task!=<span class="keyword">null</span> &amp;&amp; task.length()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">		execute(task);</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面是一个很简单的任务队列的程序，不过上面的代码还是有点不太完美的地方：当任务队列中没有任务的时候，消费者每秒都会调用一次RPOP命令查看是否有新的任务。这里我们可以借助BRPOP命令来实现一旦有新的任务队列就通知消费者，这样消费者每秒都去查看任务队列中是否有任务了。</p>
<p>上面的程序可以修改为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">	List&lt;String&gt; tasks = jedis.brpop(<span class="number">10</span>, <span class="string">"queue.task"</span>);</span><br><span class="line">	<span class="keyword">if</span> (tasks != <span class="keyword">null</span> &amp;&amp; tasks.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		execute(tasks.get(<span class="number">1</span>)); <span class="comment">// 这里要获取index为1的数据，因为index为0的数据是该队列的名字</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>BRPOP</code>命令和<code>RPOP</code>命令相似，唯一的区别就是当列表中没有元数据的时候，BRPOP命令会一直阻塞住连接，直到有新元素加入。</p>
<p>BRPOP命令接收两个参数，第一个是键名，第二个是超时时间（单位：s）。当超过了这个时间，任然没有获得到新的数据的话，就会返回nil。当设置超时时间为0的时候，表示不限制等待时间，也就是说没有新数据加入的时候，就会永远阻塞下去。</p>
<p>redis还提供了BLPOP命令，和BRPOP的区别在与从队列取数据时，BLPOP会从队列左边开始取数据，而BRPOP是从队列的右边开始取数据。</p>
<h2 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h2><p>在产品给用户发送短信的时候，有验证短信和营销短信，同样都是将短信添加到任务队列，供消费者进行处理。在没有优先级队列的时候，系统现在正在给用户发送营销短信，这是有一个用户注册了，系统要给用户发送验证短信，但是系统正在处理营销短信，按照普通任务队列，验证短信，要在营销短信发送完成之后，才开始发送，这样多影响用户体验。要是不管在什么时候，只要有发送验证短信的任务，就能立刻去处理掉，这样就好啦。</p>
<p>这样我们就需要一个具有优先级的任务队列啦，按照我们的业务逻辑，优先处理重要的任务。</p>
<p>在redis中，<code>BRPOP</code>命令可以同时接收多个键，完整的命令格式如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BRPOP queue.task.1 queue.task.2 0</span><br></pre></td></tr></table></figure>
<p>它可以同时检测多个键，如果所有的键都没有数据则阻塞，如果其中有一个键有数据则会返回响应的数据。如果多个键都有数据，则按照命令中从左到右的键的顺序取第一个有数据的键中对应的数据。这样我们就可以实现一个具有优先级的任务队列了。</p>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">	List&lt;String&gt; tasks = jedis.brpop(<span class="number">10</span>, <span class="string">"queue.task.1"</span>, <span class="string">"queue.task.2"</span>);</span><br><span class="line">	<span class="keyword">if</span> (tasks != <span class="keyword">null</span> &amp;&amp; tasks.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		execute(tasks.get(<span class="number">1</span>)); </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</div></article></div><div class="tags"><a href="/tags/redis/">redis</a></div><div class="paginator"><a href="/2016/04/01/hbase-optimize/" class="prev"><i class="fa fa-chevron-left"></i><span> Prev</span></a><a href="/2016/03/19/hbase简介/" class="next"><span>Next</span><i class="fa fa-chevron-right"></i></a></div></section><footer><section id="comments"><div data-thread-key="http://dxer.github.io/2016/03/20/redis-消息队列/index.html" data-title="Redis-消息队列" data-url="http://dxer.github.io/2016/03/20/redis-消息队列/index.html" class="ds-thread"></div><script type="text/javascript">var duoshuoQuery = {short_name: "smarthader" };
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds);
})();</script></section><div class="copyright"><p>© 2016<span class="heart"><i class="icon-next-heart fa fa-heart"></i></span><a href="http://dxer.github.io">dxer</a></p></div><div style="display:none"><script src="http://s11.cnzz.com/z_stat.php?id=1254885963&web_id=1254885963" language="JavaScript"></script></div></footer></div><label class="back2top"> <a href="#top"><i class="fa fa-chevron-up"></i></a></label></body></html>