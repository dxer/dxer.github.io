<!DOCTYPE html><html lang="en-lang"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title>HBase性能优化方法总结 · dxer</title><meta name="description" content="HBase性能优化方法总结 - dxer"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.ico"><link rel="stylesheet" href="/css/style.css"><!-- fonts--><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" href="http://fonts.lug.ustc.edu.cn/css?family=Source+Sans+Pro:400,600" type="text/css"><!-- baidu analytics--><script type="text/javascript">var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?824de59e952801cadc44270759e656b9";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><!-- google analytics--><script type="text/javascript">(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-43614462-1', 'auto');
ga('send', 'pageview');</script></head><body><input type="checkbox" id="sidebar-toggle"><aside><div class="author"><a href="/."><img src="/img/author.png" class="author-img"></a><h2 class="author-name">dxer</h2></div><div class="post-toc"><span class="toc-title">Directory</span><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Auto-Flash"><span class="toc-text">Auto Flash</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Write-Buffer"><span class="toc-text">Write Buffer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WAL-Flag"><span class="toc-text">WAL Flag</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Compression-压缩"><span class="toc-text">Compression 压缩</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#批量写"><span class="toc-text">批量写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多线程并发写"><span class="toc-text">多线程并发写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#批量读"><span class="toc-text">批量读</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#缓存查询结果"><span class="toc-text">缓存查询结果</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HBase数据表优化"><span class="toc-text">HBase数据表优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#预分区"><span class="toc-text">预分区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Rowkey优化"><span class="toc-text">Rowkey优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#减少Column-Family数量"><span class="toc-text">减少Column Family数量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#设置最大版本数"><span class="toc-text">设置最大版本数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#缓存策略（setCaching）"><span class="toc-text">缓存策略（setCaching）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#设置存储生命期"><span class="toc-text">设置存储生命期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#磁盘配置"><span class="toc-text">磁盘配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分配何时的内存给RegionServer"><span class="toc-text">分配何时的内存给RegionServer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#写数据的备份数"><span class="toc-text">写数据的备份数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#客户端一次从服务器拉取的数量"><span class="toc-text">客户端一次从服务器拉取的数量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#客户端拉取的时候指定列族"><span class="toc-text">客户端拉取的时候指定列族</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#拉取完数据之后关闭ResultScanner"><span class="toc-text">拉取完数据之后关闭ResultScanner</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RegionServer的请求处理IO线程数"><span class="toc-text">RegionServer的请求处理IO线程数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Region大小设置"><span class="toc-text">Region大小设置</span></a></li></ol></div></aside><div class="main"><header><div id="top"><a href="/." class="logo-link">dxer</a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">Home</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">Archive</a></li><li class="nav-list-item"><a href="/tags/" target="_self" class="nav-list-link">Tags</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">About</a></li></ul></div></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">HBase性能优化方法总结</h1><div class="post-time">Apr 1, 2016</div><div class="post-content"><p>本文主要是从HBase应用程序设计与开发的角度，总结几种常用的性能优化方法。<br><a id="more"></a></p>
<h3 id="Auto-Flash"><a href="#Auto-Flash" class="headerlink" title="Auto Flash"></a>Auto Flash</h3><p>通过调用<code>HTable.setAutoFlushTo(false)</code>方法可以将HTable写客户端自动flush关闭，这样可以批量写入数据到HBase，而不是有一条put就执行一次更新，只有当put填满客户端写缓存的时候，才会向HBase服务端发起写请求。默认情况下auto flush是开启的。</p>
<h3 id="Write-Buffer"><a href="#Write-Buffer" class="headerlink" title="Write Buffer"></a>Write Buffer</h3><p>通过调用<code>HTable.setWriteBufferSize(writeBufferSize)</code>方法可以设置HTable客户端的写buffer大小，如果新设置的buffer小于当前写buffer中的数据时，buffer将会被flush到服务端。其中，writeBufferSize的单位是byte字节数，可以根基实际写入数据量的多少来设置该值。</p>
<h3 id="WAL-Flag"><a href="#WAL-Flag" class="headerlink" title="WAL Flag"></a>WAL Flag</h3><p>在HBase中，客户端向集群中的RegionServer提交数据时（Put/Delete操作），首先会写到WAL（Write Ahead Log）日志，即HLog，一个RegionServer上的所有Region共享一个HLog，只有当WAL日志写成功后，再接着写MemStore，然后客户端被通知提交数据成功，如果写WAL日志失败，客户端被告知提交失败，这样做的好处是可以做到RegionServer宕机后的数据恢复。<br>对于不太重要的数据，可以在Put/Delete操作时，通过调用<code>Put.setWriteToWAL(false)</code>或<code>Delete.setWriteToWAL(false)</code>函数，放弃写WAL日志，以提高数据写入的性能。</p>
<p>注：如果关闭WAL日志，一旦RegionServer宕机，Put/Delete的数据将会无法根据WAL日志进行恢复。</p>
<h3 id="Compression-压缩"><a href="#Compression-压缩" class="headerlink" title="Compression 压缩"></a>Compression 压缩</h3><p>数据量大，边压边写也会提升性能的，毕竟IO是大数据的最严重的瓶颈，哪怕使用了SSD也是一样。众多的压缩方式中，推荐使用SNAPPY。从压缩率和压缩速度来看，性价比最高。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HColumnDescriptor hcd = <span class="keyword">new</span> HColumnDescriptor(familyName);   </span><br><span class="line">hcd.setCompressionType(Algorithm.SNAPPY);</span><br></pre></td></tr></table></figure></p>
<h3 id="批量写"><a href="#批量写" class="headerlink" title="批量写"></a>批量写</h3><p>通过调用<code>HTable.put(Put)</code>方法可以将一个指定的row key记录写入HBase，同样HBase提供了另一个方法：通过调用<code>HTable.put(List&lt;Put&gt;)</code>方法可以将指定的row key列表，批量写入多行记录，这样做的好处是批量执行，只需要一次网络I/O开销，这对于对数据实时性要求高，网络传输RTT高的情景下可能带来明显的性能提升。</p>
<h3 id="多线程并发写"><a href="#多线程并发写" class="headerlink" title="多线程并发写"></a>多线程并发写</h3><p>在客户端开启多个 HTable 写线程，每个写线程负责一个 HTable 对象的 flush 操作，这样结合定时 flush 和写 buffer（writeBufferSize），可以既保证在数据量小的时候，数据可以在较短时间内被 flush（如1秒内），同时又保证在数据量大的时候，写 buffer 一满就及时进行 flush。</p>
<h3 id="批量读"><a href="#批量读" class="headerlink" title="批量读"></a>批量读</h3><p>通过调用 <code>HTable.get(Get)</code> 方法可以根据一个指定的 row key 获取一行记录，同样 HBase 提供了另一个方法：通过调用 <code>HTable.get(List)</code> 方法可以根据一个指定的 row key 列表，批量获取多行记录，这样做的好处是批量执行，只需要一次网络 I/O 开销，这对于对数据实时性要求高而且网络传输 RTT 高的情景下可能带来明显的性能提升。</p>
<h3 id="缓存查询结果"><a href="#缓存查询结果" class="headerlink" title="缓存查询结果"></a>缓存查询结果</h3><p>对于频繁查询 HBase 的应用场景，可以考虑在应用程序中做缓存，当有新的查询请求时，首先在缓存中查找，如果存在则直接返回，不再查询 HBase；否则对 HBase 发起读请求查询，然后在应用程序中将查询结果缓存起来。至于缓存的替换策略，可以考虑 LRU 等常用的策略。</p>
<hr>
<h2 id="HBase数据表优化"><a href="#HBase数据表优化" class="headerlink" title="HBase数据表优化"></a>HBase数据表优化</h2><h3 id="预分区"><a href="#预分区" class="headerlink" title="预分区"></a>预分区</h3><p>默认情况下，在创建HBase表的时候会自动创建一个Region分区，当导入数据的时候，所有的HBase客户端都向Region写数据，知道这个Region足够大才进行切分，一种可以加快批量写入速度的方法是通过预先创建一些空的Regions，这样当数据写入HBase的时候，会按照Region分区情况，在进群内做数据的负载均衡。</p>
<h3 id="Rowkey优化"><a href="#Rowkey优化" class="headerlink" title="Rowkey优化"></a>Rowkey优化</h3><p>rowkey是按照字典存储，因此设置rowkey时，要充分利用排序特点，将经常一起读取的数据存储到一块，将最近可能会被访问的数据放到一块。<br>rowkey若是递增生成的，建议不要使用正序直接写入，可以使用字符串反转方式写入，使得rowkey大致均衡分布，这样设计的好处是能将RegionServer的负载均衡，否则容易产生所有新数据都在集中在一个RegionServer上堆积的现象，这一点还可以结合table的与分区设计。</p>
<h3 id="减少Column-Family数量"><a href="#减少Column-Family数量" class="headerlink" title="减少Column Family数量"></a>减少Column Family数量</h3><p>不要在一张表中定义太多的column family。目前HBase并不能很好的处理超过2-3个column family的表，因为某个column family在flush的时候，它临近的column family也会因关联效应被触发flush，最终导致系统产生更过的I/O;</p>
<h3 id="设置最大版本数"><a href="#设置最大版本数" class="headerlink" title="设置最大版本数"></a>设置最大版本数</h3><p>创建表的时候，可以通过 <code>HColumnDescriptor.setMaxVersions(int maxVersions)</code> 设置表中数据的最大版本，如果只需要保存最新版本的数据，那么可以设置 setMaxVersions(1)。</p>
<h3 id="缓存策略（setCaching）"><a href="#缓存策略（setCaching）" class="headerlink" title="缓存策略（setCaching）"></a>缓存策略（setCaching）</h3><p>创建表的时候，可以通过<code>HColumnDEscriptor.setInMemory(true)</code>将表放到RegionServer的缓存中，保证在读取的时候被cache命中。</p>
<h3 id="设置存储生命期"><a href="#设置存储生命期" class="headerlink" title="设置存储生命期"></a>设置存储生命期</h3><p>创建表的时候，可以通过<code>HColumnDescriptor.setTimeToLive(int timeToLive)</code>设置表中数据的存储生命周期，过期数据将自动被删除</p>
<h3 id="磁盘配置"><a href="#磁盘配置" class="headerlink" title="磁盘配置"></a>磁盘配置</h3><p>每台RegionServer管理10-1000个Regions。每个Region在1-2G，则每台server最少要10G，最大要1000*2G=2TB，考虑3备份，需要6TB。方案1是3块2TB磁盘，2是12块500G磁盘，带宽足够时，后者能提供更大的吞吐率，更细力度的冗余备份，更快速的单盘故障恢复。</p>
<h3 id="分配何时的内存给RegionServer"><a href="#分配何时的内存给RegionServer" class="headerlink" title="分配何时的内存给RegionServer"></a>分配何时的内存给RegionServer</h3><p>在不影响其他服务的情况下，越大越好。在HBase的conf目录下的hbase-env.sh的最后添加<code>export HBASE_REGIONSERVER_OPTS=&quot;- Xmx16000m $HBASE_REGIONSERVER_OPTS&quot;</code><br>其中16000m为分配给REgionServer的内存大小。</p>
<h3 id="写数据的备份数"><a href="#写数据的备份数" class="headerlink" title="写数据的备份数"></a>写数据的备份数</h3><p>备份数与读性能是成正比，与写性能成反比，且备份数影响高可用性。有两种配置方式，一种是将hdfs-site.xml拷贝到hbase的conf目录下，然后在其中添加或修改配置项<code>dfs.replication</code>的值为要设置的备份数，这种修改所有的HBase用户都生效。另一种方式是改写HBase代码，让HBase支持针对列族设置备份数，在创建表时，设置列族备份数，默认为3，此种备份数支队设置的列族生效。</p>
<h3 id="客户端一次从服务器拉取的数量"><a href="#客户端一次从服务器拉取的数量" class="headerlink" title="客户端一次从服务器拉取的数量"></a>客户端一次从服务器拉取的数量</h3><p>通过配置一次拉取较大的数据量可以减少客户端获取数据的时间，但是他会占用客户端的内存，有三个地方可以进行配置</p>
<ol>
<li>在HBase的conf配置文件中进行配置<code>hbase.client.scanner.caching</code>;</li>
<li>通过调用<code>HTble.setScannerCaching(int scannerCaching)</code>进行配置；</li>
<li>通过调用<code>Sacn.setCaching(int caching)</code>进行配置，三者的优先级越来越高。</li>
</ol>
<h3 id="客户端拉取的时候指定列族"><a href="#客户端拉取的时候指定列族" class="headerlink" title="客户端拉取的时候指定列族"></a>客户端拉取的时候指定列族</h3><p>scan是指定需要column family，可以减少网络传输数据量，否则默认scan操作会返回整行所有column family的数据</p>
<h3 id="拉取完数据之后关闭ResultScanner"><a href="#拉取完数据之后关闭ResultScanner" class="headerlink" title="拉取完数据之后关闭ResultScanner"></a>拉取完数据之后关闭ResultScanner</h3><p>通过 scan 取完数据后，记得要关闭 ResultScanner，否则 RegionServer 可能会出现问题（对应的 Server 资源无法释放）。</p>
<h3 id="RegionServer的请求处理IO线程数"><a href="#RegionServer的请求处理IO线程数" class="headerlink" title="RegionServer的请求处理IO线程数"></a>RegionServer的请求处理IO线程数</h3><p>较少的IO线程适用于处理单次请求内存消耗较高的Big Put场景（大容量单词Put或设置了较大cache的scan，均数据Big Put）或RegionServer的内存比较紧张的场景。</p>
<p>较多的IO线程，适用于单次请求内存消耗低，TPS要求（每次事务处理量）非常高的场景。这只该值的时候，以监控内存为主要参考</p>
<p>在hbase-site.xml配置文件中配置项为<code>hbase.regionserver.handle.count</code></p>
<h3 id="Region大小设置"><a href="#Region大小设置" class="headerlink" title="Region大小设置"></a>Region大小设置</h3><p>配置项<code>hbase.hregion.max.filesize</code>，所属配置文件为hbase-site.xml，默认大小是256m。</p>
<p>在当前RegionServer上单个Region的最大存储空间，单个Region超过该值时，这个Region会被自动split成更小的Region。小Region对split和compaction友好，因为拆分Region或compact小Region里的StoreFile速度非常快，内存占用低。缺点是split和compaction会很频繁，特别是数量较多的小Region不同的split，compaction，会导致集群响应时间波动很大，Region数量太多不仅给管理上带来麻烦，设置会引起一些HBase个bug。一般 512M 以下的都算小 Region。大 Region 则不太适合经常 split 和 compaction，因为做一次 compact 和 split 会产生较长时间的停顿，对应用的读写性能冲击非常大。</p>
<p>此外，大 Region 意味着较大的 StoreFile，compaction 时对内存也是一个挑战。如果你的应用场景中，某个时间点的访问量较低，那么在此时做 compact 和 split，既能顺利完成 split 和 compaction，又能保证绝大多数时间平稳的读写性能。compaction 是无法避免的，split 可以从自动调整为手动。只要通过将这个参数值调大到某个很难达到的值，比如 100G，就可以间接禁用自动 split(RegionServer 不会对未到达 100G 的 Region 做 split)。再配合 RegionSplitter 这个工具，在需要 split 时，手动 split。手动 split 在灵活性和稳定性上比起自动 split 要高很多，而且管理成本增加不多，比较推荐 online 实时系统使用。内存方面，小 Region 在设置 memstore 的大小值上比较灵活，大 Region 则过大过小都不行，过大会导致 flush 时 app 的 IO wait 增高，过小则因 StoreFile 过多影响读性能。</p>
</div></article></div><div class="tags"><a href="/tags/hbase/">hbase</a></div><div class="paginator"><a href="/2016/03/20/redis-消息队列/" class="next"><span>Next</span><i class="fa fa-chevron-right"></i></a></div></section><footer><section id="comments"><div data-thread-key="http://dxer.github.io/2016/04/01/hbase-optimize/index.html" data-title="HBase性能优化方法总结" data-url="http://dxer.github.io/2016/04/01/hbase-optimize/index.html" class="ds-thread"></div><script type="text/javascript">var duoshuoQuery = {short_name: "smarthader" };
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds);
})();</script></section><div class="copyright"><p>© 2016<span class="heart"><i class="icon-next-heart fa fa-heart"></i></span><a href="http://dxer.github.io">dxer</a></p></div><div style="display:none"><script src="http://s11.cnzz.com/z_stat.php?id=1254885963&web_id=1254885963" language="JavaScript"></script></div></footer></div><label class="back2top"> <a href="#top"><i class="fa fa-chevron-up"></i></a></label></body></html>